<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BLE Device Configuration</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }
        
        .container {
            background-color: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        h1 {
            color: #2c3e50;
            margin-top: 0;
        }
        
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
            font-size: 14px;
        }
        
        button:hover {
            background-color: #2980b9;
        }
        
        button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }
        
        .status {
            margin-top: 10px;
            font-weight: bold;
        }
        
        .success {
            color: #27ae60;
        }
        
        .error {
            color: #e74c3c;
        }
        
        .info-container {
            display: grid;
            grid-template-columns: 190px 1fr;
            row-gap: 10px;
            margin-top: 20px;
        }
        
        .topic-mono {
            font-family: monospace;
            font-size: 13px;
            word-break: break-all;
        }
        
        label {
            font-weight: bold;
        }
        
        input[type="text"], input[type="number"], input[type="password"] {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            width: 100%;
            box-sizing: border-box;
        }
        
        .mqtt-form {
            display: grid;
            grid-template-columns: 150px 1fr;
            gap: 10px;
            align-items: center;
            margin-top: 20px;
        }
        
        .device-info {
            background-color: #eaf2f8;
            padding: 15px;
            border-radius: 4px;
            margin-top: 20px;
        }
        
        .buttons-container {
            margin-top: 20px;
        }
        
        .hidden {
            display: none;
        }
        
        .logs {
            margin-top: 20px;
            background-color: #2c3e50;
            color: #ecf0f1;
            padding: 10px;
            border-radius: 4px;
            max-height: 200px;
            overflow-y: auto;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>BLE Device Configuration</h1>
        
        <div class="info-note" style="background-color: #ffeeba; padding: 10px; border-radius: 4px; margin-bottom: 15px;">
            <strong>Disclaimer:</strong> Use this application at your own risk. The developers are not responsible for any issues arising from its use.

        </div>
        
        <div>
            <button id="connect-button">Connect to Device</button>
            <button id="disconnect-button" disabled>Disconnect</button>
            <div id="connection-status" class="status">Not connected</div>
        </div>
        
        <div id="device-info-container" class="hidden">
            <h2>Device Information</h2>
            <button id="get-info-button">Get Device Info</button>
            
            <div id="device-info" class="device-info hidden">
                <div class="info-container">
                    <div>Type:</div>
                    <div id="device-type">-</div>
                    <div>ID:</div>
                    <div id="device-id">-</div>
                    <div>MAC:</div>
                    <div id="device-mac">-</div>
                    <div>Firmware Version:</div>
                    <div id="device-version">-</div>
                    <div>Status:</div>
                    <div id="info-status">Not fetched</div>
                </div>
                <div style="margin-top: 10px; font-size: 12px; color: #666;">
                    Last updated: <span id="last-update-time">Never</span>
                </div>
            </div>
        </div>
        
        <div id="mqtt-container" class="hidden">
            <h2>MQTT Configuration</h2>
            
            <form id="mqtt-form" class="mqtt-form">
                <label for="ssl">SSL Enabled:</label>
                <input type="checkbox" id="ssl" name="ssl">
                
                <label for="host">Host:</label>
                <input type="text" id="host" name="host" placeholder="192.168.1.100" required>
                
                <label for="port">Port:</label>
                <input type="number" id="port" name="port" placeholder="1883" required>
                
                <label for="username">Username:</label>
                <input type="text" id="username" name="username" placeholder="username">
                
                <label for="password">Password:</label>
                <input type="password" id="password" name="password" placeholder="password">
            </form>
            
            <div class="buttons-container">
                <button id="set-mqtt-button">Set MQTT Config</button>
                <button id="reset-mqtt-button">Reset MQTT Config</button>
            </div>
        </div>
        
        <div id="hame-relay-container" class="hidden">
            <h2>Hame Relay Configuration</h2>
            
            <div style="margin-bottom: 20px;">
                <h3>Choose Relay Mode:</h3>
                <div style="margin: 10px 0;">
                    <input type="radio" id="mode1" name="relay-mode" value="false" checked>
                    <label for="mode1" style="margin-left: 5px; font-weight: normal;">
                        <strong>Mode 1 (Recommended):</strong> Device uses local MQTT broker - use the MQTT config above (inverse_forwarding: false)
                    </label>
                </div>
                <div style="margin: 10px 0;">
                    <input type="radio" id="mode2" name="relay-mode" value="true">
                    <label for="mode2" style="margin-left: 5px; font-weight: normal;">
                        <strong>Mode 2:</strong> Device uses Hame cloud MQTT broker (inverse_forwarding: true)
                    </label>
                </div>
            </div>
            
            <div style="margin-bottom: 20px;">
                <h3>MQTT Topic for Local Automation:</h3>
                <div style="background-color: #f8f9fa; padding: 10px; border-radius: 4px; font-family: monospace; word-break: break-all; margin-bottom: 10px;" id="local-topic">
                    Subscribe to this topic in your local MQTT broker
                </div>
                <button onclick="copyToClipboard('local-topic')" style="font-size: 12px;">Copy Topic</button>
            </div>
            
            <div style="margin-bottom: 20px;">
                <h3>Home Assistant Add-on Configuration:</h3>
                <pre id="ha-config" style="background-color: #2c3e50; color: #ecf0f1; padding: 15px; border-radius: 4px; overflow-x: auto; font-size: 12px; margin-bottom: 10px;">inverse_forwarding: false
devices:
  - device_id: "your-device-id"
    mac: "your-mac-address"
    type: "your-device-type"
    version: 0</pre>
                <button onclick="copyToClipboard('ha-config')" style="font-size: 12px;">Copy HA Config</button>
            </div>
            
            <div style="margin-bottom: 20px;">
                <h3>Docker Configuration (config/config.json):</h3>
                <pre id="docker-config" style="background-color: #2c3e50; color: #ecf0f1; padding: 15px; border-radius: 4px; overflow-x: auto; font-size: 12px; margin-bottom: 10px;">{
  "broker_url": "mqtt://username:password@your-broker-url",
  "inverse_forwarding": false,
  "devices": [
    {
      "device_id": "your-device-id",
      "mac": "your-mac-address",
      "type": "your-device-type",
      "version": 0
    }
  ]
}</pre>
                <button onclick="copyToClipboard('docker-config')" style="font-size: 12px;">Copy Docker Config</button>
            </div>
            
            <div class="info-note" style="background-color: #fff3cd; padding: 10px; border-radius: 4px; margin-bottom: 15px;">
                <strong>Installation:</strong> 
                <a href="https://github.com/tomquist/hame-relay#docker" target="_blank">Docker instructions</a> | 
                <a href="https://github.com/tomquist/hame-relay#home-assistant" target="_blank">Home Assistant Add-on</a>
            </div>
            
            <div style="margin-bottom: 20px;">
                <h3>Optional: Monitor Your Device with hm2mqtt</h3>
                <div class="info-note" style="background-color: #e8f5e8; padding: 10px; border-radius: 4px; margin-bottom: 10px;">
                    After setting up Hame Relay, you can also install <strong>hm2mqtt</strong> to get detailed monitoring data in Home Assistant.
                </div>
                
                <h4>Home Assistant Add-on (Recommended):</h4>
                <div style="margin-bottom: 10px;">
                    1. Add repository: <a href="https://github.com/tomquist/hm2mqtt" target="_blank">https://github.com/tomquist/hm2mqtt</a><br>
                    2. Install "hm2mqtt" add-on<br>
                    3. Use this device configuration:
                </div>
                <pre id="hm2mqtt-ha-config" style="background-color: #2c3e50; color: #ecf0f1; padding: 15px; border-radius: 4px; overflow-x: auto; font-size: 12px; margin-bottom: 10px;">pollingInterval: 60
responseTimeout: 30
topicPrefix: hm2mqtt
devices:
  - deviceType: "your-device-type"
    deviceId: "your-device-mac"</pre>
                <button onclick="copyToClipboard('hm2mqtt-ha-config')" style="font-size: 12px;">Copy hm2mqtt Config</button>
                
                <h4 style="margin-top: 15px;">Docker:</h4>
                <pre id="hm2mqtt-docker-config" style="background-color: #2c3e50; color: #ecf0f1; padding: 15px; border-radius: 4px; overflow-x: auto; font-size: 12px; margin-bottom: 10px;">docker run -d --name hm2mqtt \
  -e MQTT_BROKER_URL=mqtt://192.168.1.100:1883 \
  -e MQTT_USERNAME=your-username \
  -e MQTT_PASSWORD=your-password \
  -e DEVICE_0=your-device-type:your-device-mac \
  --restart=unless-stopped \
  ghcr.io/tomquist/hm2mqtt:latest</pre>
                <button onclick="copyToClipboard('hm2mqtt-docker-config')" style="font-size: 12px;">Copy Docker Command</button>
                
                <div style="margin-top: 10px; font-size: 12px; color: #666;">
                    <strong>Note:</strong> hm2mqtt provides detailed battery monitoring data like cell voltages, temperature, and power flow - perfect for comprehensive energy management in Home Assistant.
                </div>
            </div>
        </div>
    </div>
    
    <div class="container">
        <h2>Debug Logs</h2>
        <div id="logs" class="logs"></div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/aes-js@3.1.2/index.min.js"></script>
    <script>
        // BLE Service and Characteristic UUIDs
        const SERVICE_UUID = '0000ff00-0000-1000-8000-00805f9b34fb';
        const COMMAND_CHARACTERISTIC_UUID = '0000ff01-0000-1000-8000-00805f9b34fb';
        const STATUS_CHARACTERISTIC_UUID = '0000ff02-0000-1000-8000-00805f9b34fb';
        
        // Command bytes
        const START_BYTE = 0x73;
        const IDENTIFIER_BYTE = 0x23;
        const VERSION_COMMAND = 0x03;
        const DEVICE_INFO_COMMAND = 0x04;
        const SET_MQTT_COMMAND = 0x20;
        const RESET_MQTT_COMMAND = 0x21;
        
        // Global variables
        let bluetoothDevice;
        let commandCharacteristic;
        let statusCharacteristic;
        
        // DOM elements
        const connectButton = document.getElementById('connect-button');
        const disconnectButton = document.getElementById('disconnect-button');
        const connectionStatus = document.getElementById('connection-status');
        const deviceInfoContainer = document.getElementById('device-info-container');
        const getInfoButton = document.getElementById('get-info-button');
        const deviceInfo = document.getElementById('device-info');
        const deviceType = document.getElementById('device-type');
        const deviceId = document.getElementById('device-id');
        const deviceMac = document.getElementById('device-mac');
        const deviceVersion = document.getElementById('device-version');
        const mqttContainer = document.getElementById('mqtt-container');
        const mqttForm = document.getElementById('mqtt-form');
        const setMqttButton = document.getElementById('set-mqtt-button');
        const resetMqttButton = document.getElementById('reset-mqtt-button');
        const logsElement = document.getElementById('logs');
        
        // Add a checkbox for auto-reconnect
        const autoReconnectCheckbox = document.createElement('input');
        autoReconnectCheckbox.type = 'checkbox';
        autoReconnectCheckbox.id = 'auto-reconnect';
        autoReconnectCheckbox.checked = true;
        
        const autoReconnectLabel = document.createElement('label');
        autoReconnectLabel.htmlFor = 'auto-reconnect';
        autoReconnectLabel.textContent = 'Auto-reconnect on disconnect';
        autoReconnectLabel.style.marginLeft = '10px';
        
        // Insert auto-reconnect elements after the connection status
        const connStatusParent = connectionStatus.parentNode;
        connStatusParent.appendChild(document.createElement('br'));
        connStatusParent.appendChild(autoReconnectCheckbox);
        connStatusParent.appendChild(autoReconnectLabel);
        
        // Log function
        function log(message) {
            console.log(message);
            const logEntry = document.createElement('div');
            logEntry.textContent = `${new Date().toLocaleTimeString()} - ${message}`;
            logsElement.appendChild(logEntry);
            logsElement.scrollTop = logsElement.scrollHeight;
        }
        
        // Helper function to convert string to byte array
        function stringToBytes(str) {
            const encoder = new TextEncoder();
            return encoder.encode(str);
        }
        
        // Helper function to convert byte array to string
        function bytesToString(bytes) {
            const decoder = new TextDecoder('utf-8');
            return decoder.decode(bytes);
        }
        
        // Calculate checksum (XOR of all bytes)
        function calculateChecksum(bytes) {
            return bytes.reduce((xor, byte) => xor ^ byte, 0);
        }
        
        // Connect to BLE device
        async function connectToDevice() {
            try {
                // Get the service UUID (now hardcoded)
                const currentServiceUuid = SERVICE_UUID;
                
                log('Requesting Bluetooth device...');
                log(`Using Service UUID: ${currentServiceUuid}`);
                
                // Store for later use
                window.currentServiceUuid = currentServiceUuid;
                
                // Use name prefix filter directly without prompting
                log('Using name prefix filter: "HM_B2500"');
                
                // Apply the name prefix filter
                bluetoothDevice = await navigator.bluetooth.requestDevice({
                    filters: [
                        { namePrefix: 'HM_B2500' }
                    ],
                    // Include our service as an optional service
                    optionalServices: [currentServiceUuid]
                });
                
                log(`Selected device ID: ${bluetoothDevice.id}`);
                log(`Selected device name: ${bluetoothDevice.name || 'unnamed device'}`);
                
                // Check for GATT connection
                if (!bluetoothDevice.gatt) {
                    throw new Error('Device does not support GATT');
                }
                
                bluetoothDevice.addEventListener('gattserverdisconnected', onDisconnected);
                
                log('Connecting to GATT server...');
                const server = await bluetoothDevice.gatt.connect();
                
                log('Getting primary service...');
                log(`Requesting service: ${SERVICE_UUID}`);
                
                try {
                    const service = await server.getPrimaryService(SERVICE_UUID);
                    log('Service found!');
                } catch (serviceError) {
                    log(`Error finding service: ${serviceError}`);
                    
                    // Offer to show all available services
                    const showAllServices = confirm('Service not found. Would you like to see all available services?');
                    
                    if (showAllServices) {
                        try {
                            log('Discovering all services...');
                            const services = await server.getPrimaryServices();
                            log(`Found ${services.length} services:`);
                            
                            services.forEach(async (service, index) => {
                                log(`Service ${index + 1}: ${service.uuid}`);
                                
                                try {
                                    // Try to get characteristics for each service
                                    const characteristics = await service.getCharacteristics();
                                    log(`Service ${index + 1} has ${characteristics.length} characteristics:`);
                                    
                                    characteristics.forEach((characteristic, charIndex) => {
                                        log(`- Characteristic ${charIndex + 1}: ${characteristic.uuid}`);
                                    });
                                } catch (error) {
                                    log(`Could not read characteristics for service ${index + 1}: ${error}`);
                                }
                            });
                            
                            alert('Check the debug logs for a list of all available services and characteristics.');
                            throw new Error('Required service not found. See logs for available services.');
                        } catch (discoveryError) {
                            log(`Error discovering services: ${discoveryError}`);
                            throw discoveryError;
                        }
                    } else {
                        throw serviceError;
                    }
                }
                
                // Try again with the service we now know exists
                const service = await server.getPrimaryService(SERVICE_UUID);
                
                log('Getting command characteristic...');
                commandCharacteristic = await service.getCharacteristic(COMMAND_CHARACTERISTIC_UUID);
                
                log('Getting status characteristic...');
                statusCharacteristic = await service.getCharacteristic(STATUS_CHARACTERISTIC_UUID);
                
                // Update UI
                connectButton.disabled = true;
                disconnectButton.disabled = false;
                connectionStatus.textContent = 'Connected';
                connectionStatus.classList.add('success');
                deviceInfoContainer.classList.remove('hidden');
                mqttContainer.classList.remove('hidden');
                
                log('Connected successfully');
                
                // Automatically fetch device info after a short delay
                setTimeout(async () => {
                    log('Automatically fetching device information and firmware version...');
                    await getDeviceInformation();
                }, 1000);
            } catch (error) {
                log(`Connection error: ${error}`);
                connectionStatus.textContent = `Connection failed: ${error}`;
                connectionStatus.classList.add('error');
            }
        }
        
        // Disconnect from BLE device
        function disconnectFromDevice() {
            if (bluetoothDevice && bluetoothDevice.gatt.connected) {
                bluetoothDevice.gatt.disconnect();
            } else {
                onDisconnected();
            }
        }
        
        // Handle disconnection
        function onDisconnected() {
            log('Device disconnected');
            
            // Update UI
            connectButton.disabled = false;
            disconnectButton.disabled = true;
            connectionStatus.textContent = 'Disconnected';
            connectionStatus.classList.remove('success');
            deviceInfoContainer.classList.add('hidden');
            deviceInfo.classList.add('hidden');
            mqttContainer.classList.add('hidden');
            
            // Reset device info
            deviceType.textContent = '-';
            deviceId.textContent = '-';
            deviceMac.textContent = '-';
            deviceVersion.textContent = '-';
            
            // Save current device ID for potential reconnection
            const lastDeviceId = bluetoothDevice ? bluetoothDevice.id : null;
            
            // Clear global variables
            commandCharacteristic = null;
            statusCharacteristic = null;
            
            // Check for auto-reconnect
            const autoReconnect = document.getElementById('auto-reconnect').checked;
            if (autoReconnect && lastDeviceId && bluetoothDevice) {
                log('Auto-reconnect is enabled. Attempting to reconnect...');
                
                // Keep a reference to the device
                const deviceToReconnect = bluetoothDevice;
                bluetoothDevice = null;
                
                // Try to reconnect after a short delay
                setTimeout(async () => {
                    try {
                        log(`Reconnecting to device ID: ${lastDeviceId}`);
                        
                        // Connect to GATT server
                        log('Connecting to GATT server...');
                        const server = await deviceToReconnect.gatt.connect();
                        
                        bluetoothDevice = deviceToReconnect;
                        
                        // Continue with normal connection process
                        log('Getting primary service...');
                        log(`Requesting service: ${SERVICE_UUID}`);
                        const service = await server.getPrimaryService(SERVICE_UUID);
                        
                        log('Getting command characteristic...');
                        commandCharacteristic = await service.getCharacteristic(COMMAND_CHARACTERISTIC_UUID);
                        
                        log('Getting status characteristic...');
                        statusCharacteristic = await service.getCharacteristic(STATUS_CHARACTERISTIC_UUID);
                        
                        // Update UI
                        connectButton.disabled = true;
                        disconnectButton.disabled = false;
                        connectionStatus.textContent = 'Reconnected';
                        connectionStatus.classList.add('success');
                        deviceInfoContainer.classList.remove('hidden');
                        mqttContainer.classList.remove('hidden');
                        
                        log('Reconnected successfully');
                        
                        // Automatically fetch device info
                        setTimeout(async () => {
                            log('Automatically fetching device information after reconnect...');
                            await getDeviceInformation();
                        }, 1000);
                    } catch (error) {
                        log(`Reconnection failed: ${error}`);
                        bluetoothDevice = null;
                    }
                }, 2000);
            } else {
                bluetoothDevice = null;
            }
        }
        
        // Send command to get firmware version
        async function getFirmwareVersion() {
            if (!commandCharacteristic || !statusCharacteristic) {
                log('Cannot get firmware version: device not connected');
                return null;
            }
            
            log('Requesting firmware version...');
            
            try {
                // Add a small delay to avoid interfering with other commands
                await new Promise(resolve => setTimeout(resolve, 500));
                // Create and send the version command
                const versionCommand = [START_BYTE, 0, IDENTIFIER_BYTE, VERSION_COMMAND];
                versionCommand[1] = versionCommand.length + 1; // +1 for checksum
                versionCommand.push(calculateChecksum(versionCommand));
                
                log(`Sending version command: ${versionCommand.map(b => '0x' + b.toString(16).padStart(2, '0')).join(' ')}`);
                
                // Wait for response
                const responseData = await new Promise((resolve, reject) => {
                    // Set up notification listener
                    const handler = (event) => {
                        const value = event.target.value;
                        const response = new Uint8Array(value.buffer);
                        log(`Received version response (${response.length} bytes): ${Array.from(response).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' ')}`);
                        statusCharacteristic.removeEventListener('characteristicvaluechanged', handler);
                        resolve(response);
                    };
                    
                    // Add event listener
                    statusCharacteristic.addEventListener('characteristicvaluechanged', handler);
                    
                    // Enable notifications and send command
                    statusCharacteristic.startNotifications()
                        .then(() => {
                            return commandCharacteristic.writeValue(new Uint8Array(versionCommand));
                        })
                        .then(() => {
                            log('Version command sent');
                        })
                        .catch(err => {
                            statusCharacteristic.removeEventListener('characteristicvaluechanged', handler);
                            reject(err);
                        });
                    
                    // Set timeout (shorter timeout for version command)
                    setTimeout(() => {
                        statusCharacteristic.removeEventListener('characteristicvaluechanged', handler);
                        reject(new Error('Version command timeout'));
                    }, 3000);
                });
                
                // Extract version from byte 12 (0-indexed, so position 12)
                if (responseData.length > 12) {
                    const version = responseData[12];
                    log(`Firmware version extracted: ${version}`);
                    return version;
                } else {
                    log(`Version response too short (${responseData.length} bytes), expected at least 13 bytes`);
                    return null;
                }
            } catch (error) {
                log(`Error getting firmware version: ${error}`);
                return null;
            }
        }

        // Send command to get device information - SIMPLIFIED TWO-PHASE APPROACH
        async function getDeviceInformation() {
            if (!commandCharacteristic || !statusCharacteristic) {
                log('Cannot get device information: device not connected');
                return;
            }
            
            log('Requesting device information...');
            
            // Disable the Get Info button during the operation
            const getInfoButton = document.getElementById('get-info-button');
            getInfoButton.disabled = true;
            getInfoButton.textContent = 'Getting Info...';
            
            // Update status
            const infoStatus = document.getElementById('info-status');
            infoStatus.textContent = 'Fetching...';
            infoStatus.style.color = '#ff9900';
            
            try {
                // TWO-PHASE APPROACH:
                // This device consistently needs two commands, with the second one being the one that works
                log('Using two-phase approach for this device');
                
                // Note: Version retrieval moved to after device info for better compatibility
                let firmwareVersion = null;
                
                // FIRST PHASE - EXPECTED TO FAIL:
                log('Phase 1: Sending initial command (expected to fail)');
                
                // Create and send the command
                const phase1Command = [START_BYTE, 0, IDENTIFIER_BYTE, DEVICE_INFO_COMMAND];
                phase1Command[1] = phase1Command.length + 1; // +1 for checksum
                phase1Command.push(calculateChecksum(phase1Command));
                
                log(`Sending phase 1 command: ${phase1Command.map(b => '0x' + b.toString(16).padStart(2, '0')).join(' ')}`);
                
                // Set up notification for phase 1 (with short timeout)
                let phase1Success = false;
                
                try {
                    // Only wait briefly - we expect this to fail
                    await new Promise((resolve, reject) => {
                        // Set up notification listener
                        const handler = (event) => {
                            phase1Success = true;
                            statusCharacteristic.removeEventListener('characteristicvaluechanged', handler);
                            resolve('Unexpected phase 1 success');
                        };
                        
                        // Add event listener
                        statusCharacteristic.addEventListener('characteristicvaluechanged', handler);
                        
                        // Enable notifications
                        statusCharacteristic.startNotifications()
                            .then(() => {
                                // Send command
                                return commandCharacteristic.writeValue(new Uint8Array(phase1Command));
                            })
                            .then(() => {
                                log('Phase 1 command sent and notifications started');
                                
                                // Add short timeout
                                setTimeout(() => {
                                    if (!phase1Success) {
                                        statusCharacteristic.removeEventListener('characteristicvaluechanged', handler);
                                        reject(new Error('Phase 1 timeout (expected)'));
                                    }
                                }, 2000); // Short 2-second timeout
                            })
                            .catch(err => reject(err));
                    });
                    
                    log('Phase 1 unexpectedly succeeded - device may have changed behavior');
                } catch (phase1Error) {
                    // This is expected - phase 1 should time out
                    log(`Phase 1 completed with expected timeout: ${phase1Error}`);
                }
                
                // SECOND PHASE - EXPECTED TO SUCCEED:
                log('Phase 2: Sending follow-up command (expected to succeed)');
                
                // Create the same command again for phase 2
                const phase2Command = [START_BYTE, 0, IDENTIFIER_BYTE, DEVICE_INFO_COMMAND];
                phase2Command[1] = phase2Command.length + 1; // +1 for checksum
                phase2Command.push(calculateChecksum(phase2Command));
                
                log(`Sending phase 2 command: ${phase2Command.map(b => '0x' + b.toString(16).padStart(2, '0')).join(' ')}`);
                
                // Wait for response from phase 2
                const responseData = await new Promise((resolve, reject) => {
                    // Set up notification listener
                    const handler = (event) => {
                        const value = event.target.value;
                        const response = bytesToString(new Uint8Array(value.buffer));
                        log(`Received phase 2 response: ${response}`);
                        statusCharacteristic.removeEventListener('characteristicvaluechanged', handler);
                        resolve(response);
                    };
                    
                    // Add event listener
                    statusCharacteristic.addEventListener('characteristicvaluechanged', handler);
                    
                    // Enable notifications and send command
                    statusCharacteristic.startNotifications()
                        .then(() => {
                            log('Phase 2 notifications started');
                            return commandCharacteristic.writeValue(new Uint8Array(phase2Command));
                        })
                        .then(() => {
                            log('Phase 2 command sent');
                        })
                        .catch(err => {
                            statusCharacteristic.removeEventListener('characteristicvaluechanged', handler);
                            reject(err);
                        });
                    
                    // Set timeout for phase 2
                    setTimeout(() => {
                        statusCharacteristic.removeEventListener('characteristicvaluechanged', handler);
                        reject(new Error('Phase 2 timeout - device not responding'));
                    }, 10000); // 10-second timeout for phase 2
                });
                
                // If we get here, we have a response
                
                // Parse the response
                log(`Parsing response: ${responseData}`);
                
                // Clean the response (remove s<# prefix and control characters)
                const cleanedResponse = responseData.slice(4, -1);
                log(`Cleaned response: ${cleanedResponse}`);
                
                // Parse into key-value pairs
                const parts = cleanedResponse.split(',');
                const parsedInfo = {};
                
                parts.forEach(part => {
                    const keyValue = part.trim().split('=');
                    if (keyValue.length === 2) {
                        const key = keyValue[0].trim();
                        const value = keyValue[1].trim();
                        if (key && value) {
                            parsedInfo[key] = value;
                        }
                    }
                });
                
                log(`Parsed info: ${JSON.stringify(parsedInfo)}`);
                
                // Check if version is already in device info first
                if (parsedInfo.version) {
                    log(`Found firmware version in device info: ${parsedInfo.version}`);
                } else if (parsedInfo.ver) {
                    parsedInfo.version = parsedInfo.ver;
                    log(`Found firmware version as 'ver' in device info: ${parsedInfo.ver}`);
                } else {
                    // Try to get firmware version via command as fallback
                    try {
                        log('Attempting to get firmware version via command...');
                        firmwareVersion = await getFirmwareVersion();
                        if (firmwareVersion !== null) {
                            parsedInfo.version = firmwareVersion;
                            log(`Added firmware version from version command: ${firmwareVersion}`);
                        } else {
                            log('No firmware version available from device');
                        }
                    } catch (versionError) {
                        log(`Firmware version command failed: ${versionError}`);
                        log('No firmware version available from device');
                    }
                }
                
                // Update UI
                deviceType.textContent = parsedInfo.type || 'Unknown';
                deviceId.textContent = parsedInfo.id || 'Unknown';
                deviceMac.textContent = parsedInfo.mac || 'Unknown';
                document.getElementById('device-version').textContent = parsedInfo.version || 'Unknown';
                // Always show both topics, and set correct threshold in label
                let mac = parsedInfo.mac || '';
                let type = parsedInfo.type || '';
                let macNoColons = mac.replace(/:/g, '').toLowerCase();
                let encryptedMac = calculateNewVersionTopicId(macNoColons);
                let oldTopic = `hame_energy/${type}/device/${macNoColons}/ctrl`;
                let newTopic = `marstek_energy/${type}/device/${encryptedMac}/ctrl`;
                let oldAppTopic = `hame_energy/${type}/App/${macNoColons}/ctrl`;
                let newAppTopic = `marstek_energy/${type}/App/${encryptedMac}/ctrl`;
                // Determine exact firmware threshold and topic display
                // HMJ devices (B2500/Saturn) use 108, HMA devices use 226, HMB devices always use non-encrypted
                if (/^HMB-\d+$/i.test(type)) {
                    // HMB devices always use non-encrypted topics
                    document.getElementById('device-topic-ge-label').textContent = 'MQTT Topic:';
                    document.getElementById('device-topic-ge').textContent = oldTopic;
                    document.getElementById('device-topic-ge-app').textContent = oldAppTopic;
                    document.getElementById('device-topic-lt-label').textContent = '';
                    document.getElementById('device-topic-lt').textContent = '';
                    document.getElementById('device-topic-lt-app').textContent = '';
                } else {
                    // HMJ and HMA devices can use either topic based on firmware
                    let threshold = /^HMJ-\d+$/i.test(type) ? 108 : 226;
                    document.getElementById('device-topic-ge-label').textContent = `Topic for firmware =${threshold}:`;
                    document.getElementById('device-topic-ge').textContent = newTopic;
                    document.getElementById('device-topic-ge-app').textContent = newAppTopic;
                    document.getElementById('device-topic-lt-label').textContent = `Topic for firmware â‰ ${threshold}:`;
                    document.getElementById('device-topic-lt').textContent = oldTopic;
                    document.getElementById('device-topic-lt-app').textContent = oldAppTopic;
                }
                deviceInfo.classList.remove('hidden');
                
                // Show Hame Relay configuration section
                updateHameRelayConfig(parsedInfo);
                document.getElementById('hame-relay-container').classList.remove('hidden');
                
                // Check if this is actually a B2500 device and show warning if not
                if (!/^HMJ-\d+$/i.test(type)) {
                    log(`Warning: Device type ${type} detected - this tool is designed for B2500 (HMJ) devices`);
                }
                
                // Update status
                document.getElementById('info-status').textContent = 'Success';
                document.getElementById('info-status').style.color = 'green';
                
                // Update last update time
                const now = new Date();
                document.getElementById('last-update-time').textContent = now.toLocaleTimeString();
                
                log('Device information retrieved successfully');
            } catch (error) {
                log(`Error getting device information: ${error}`);
                document.getElementById('info-status').textContent = 'Failed';
                document.getElementById('info-status').style.color = 'red';
                alert(`Failed to get device information: ${error}`);
            } finally {
                // Re-enable the button
                getInfoButton.disabled = false;
                getInfoButton.textContent = 'Get Device Info';
            }
        }
        
        // Send command to set MQTT configuration
        async function setMqttConfig() {
            try {
                if (!commandCharacteristic) {
                    throw new Error('Device not connected');
                }
                
                // Get form values
                const formData = new FormData(mqttForm);
                const sslEnabled = document.getElementById('ssl').checked ? '1' : '0';
                const host = document.getElementById('host').value;
                const port = document.getElementById('port').value;
                const username = document.getElementById('username').value;
                const password = document.getElementById('password').value;
                
                // Validate required fields
                if (!host || !port) {
                    throw new Error('Host and port are required');
                }
                
                // Create MQTT config string
                const configStr = `${sslEnabled}<.,.>${host}<.,.>${port}<.,.>${username}<.,.>${password}<.,.>`;
                log(`MQTT Config String: ${configStr}`);
                
                // Convert config string to bytes
                const configBytes = stringToBytes(configStr);
                
                // Prepare command
                const commandPrefix = [START_BYTE, 0, IDENTIFIER_BYTE, SET_MQTT_COMMAND];
                const command = new Uint8Array(commandPrefix.length + configBytes.length + 1); // +1 for checksum
                
                // Copy command prefix
                command.set(commandPrefix);
                
                // Copy config bytes
                command.set(configBytes, commandPrefix.length);
                
                // Set length
                command[1] = command.length;
                
                // Calculate and set checksum
                const checksumIndex = command.length - 1;
                let checksum = 0;
                for (let i = 0; i < checksumIndex; i++) {
                    checksum ^= command[i];
                }
                command[checksumIndex] = checksum;
                
                log(`Sending MQTT config command (${command.length} bytes): ${Array.from(command).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' ')}`);
                
                // Add a confirmation
                if (!confirm(`Are you sure you want to configure MQTT with the following settings?\n\nHost: ${host}\nPort: ${port}\nSSL: ${sslEnabled === '1' ? 'Enabled' : 'Disabled'}\nUsername: ${username ? '(set)' : '(not set)'}\nPassword: ${password ? '(set)' : '(not set)'}`)) {
                    log('Set MQTT operation cancelled by user');
                    return;
                }
                
                // Set a visual feedback that the command is being sent
                setMqttButton.disabled = true;
                setMqttButton.textContent = 'Sending...';
                
                try {
                    // Send command
                    await commandCharacteristic.writeValue(command);
                    
                    log('MQTT configuration sent successfully');
                    alert('MQTT configuration set successfully');
                } finally {
                    // Reset button state
                    setMqttButton.disabled = false;
                    setMqttButton.textContent = 'Set MQTT Config';
                }
            } catch (error) {
                log(`Error setting MQTT config: ${error}`);
                alert(`Failed to set MQTT configuration: ${error}`);
            }
        }
        
        // Send command to reset MQTT configuration
        async function resetMqttConfig() {
            try {
                if (!commandCharacteristic) {
                    throw new Error('Device not connected');
                }
                
                log('Resetting MQTT configuration...');
                
                // Prepare command
                const command = [START_BYTE, 0, IDENTIFIER_BYTE, RESET_MQTT_COMMAND];
                command[1] = command.length + 1; // +1 for checksum
                command.push(calculateChecksum(command));
                
                log(`Sending reset MQTT command: ${command.map(b => '0x' + b.toString(16).padStart(2, '0')).join(' ')}`);
                
                // Add a confirmation
                if (!confirm('Are you sure you want to reset the MQTT configuration?')) {
                    log('Reset MQTT operation cancelled by user');
                    return;
                }
                
                // Send command
                await commandCharacteristic.writeValue(new Uint8Array(command));
                
                log('MQTT configuration reset successfully');
                alert('MQTT configuration reset successfully');
            } catch (error) {
                log(`Error resetting MQTT config: ${error}`);
                alert(`Failed to reset MQTT configuration: ${error}`);
            }
        }
        
        // --- Topic Calculation Helpers ---
        // AES key and IV for new topic
        const NEW_TOPIC_KEY = [33,64,35,36,37,94,38,42,40,41,95,43,123,125,91,93];
        const NEW_TOPIC_IV = new Array(16).fill(0);

        // Pad to 16 bytes (PKCS7)
        function pkcs7Pad(bytes) {
            const padLen = 16 - (bytes.length % 16);
            const padded = new Uint8Array(bytes.length + padLen);
            padded.set(bytes);
            padded.fill(padLen, bytes.length);
            return padded;
        }

        // Calculate new version topic encrypted MAC (browser version)
        function calculateNewVersionTopicId(mac) {
            const aesCbc = new aesjs.ModeOfOperation.cbc(NEW_TOPIC_KEY, NEW_TOPIC_IV);
            // MAC is a string, encode as UTF-8 bytes
            const macBytes = aesjs.utils.utf8.toBytes(mac);
            const padded = pkcs7Pad(macBytes);
            const encryptedBytes = aesCbc.encrypt(padded);
            return aesjs.utils.hex.fromBytes(encryptedBytes);
        }

        // --- Topic Calculation Logic ---
        function getDeviceTopic(type, version, mac) {
            // type: string, version: string or number, mac: string
            // If device type is HMJ-X (X is an arbitrary number) and version =108,
            // or if device type is not HMJ-X and version =226, use new topic
            // else use old topic
            let topic = '';
            let encryptedMac = '';
            let macNoColons = (mac || '').replace(/:/g, '').toLowerCase();
            let typeUpper = (type || '').toUpperCase();
            let versionNum = parseInt(version, 10);
            if (/^HMJ-\d+$/i.test(typeUpper)) {
                if (versionNum === 108) {
                    encryptedMac = calculateNewVersionTopicId(macNoColons);
                    topic = `marstek_energy/${type}/device/${encryptedMac}/ctrl`;
                } else {
                    topic = `hame_energy/${type}/device/${macNoColons}/ctrl`;
                }
            } else {
                if (versionNum === 226) {
                    encryptedMac = calculateNewVersionTopicId(macNoColons);
                    topic = `marstek_energy/${type}/device/${encryptedMac}/ctrl`;
                } else {
                    topic = `hame_energy/${type}/device/${macNoColons}/ctrl`;
                }
            }
            return topic;
        }

        // Update Hame Relay configuration section
        function updateHameRelayConfig(deviceInfo) {
            const mac = deviceInfo.mac || '';
            const type = deviceInfo.type || '';
            const deviceId = deviceInfo.id || '';
            const macNoColons = mac.replace(/:/g, '').toLowerCase();
            const version = deviceInfo.version || 0;
            
            // Determine which topic to use based on device type and firmware version
            let localTopic;
            if (/^HMB-\d+$/i.test(type)) {
                // HMB devices always use non-encrypted topics
                localTopic = `hame_energy/${type}/device/${macNoColons}/ctrl`;
            } else {
                // HMJ devices use 108 threshold, HMA devices use 226 threshold
                const threshold = /^HMJ-\d+$/i.test(type) ? 108 : 226;
                const usesEncryptedTopic = parseInt(version, 10) === threshold;
                
                if (usesEncryptedTopic) {
                    const encryptedMac = calculateNewVersionTopicId(macNoColons);
                    localTopic = `marstek_energy/${type}/device/${encryptedMac}/ctrl`;
                } else {
                    localTopic = `hame_energy/${type}/device/${macNoColons}/ctrl`;
                }
            }
            
            // Update topic display
            document.getElementById('local-topic').textContent = localTopic;
            
            // Update configuration templates
            updateConfigTemplates(deviceId, macNoColons, type, version);
            
            // Add event listeners for mode selection
            const mode1Radio = document.getElementById('mode1');
            const mode2Radio = document.getElementById('mode2');
            
            mode1Radio.addEventListener('change', () => {
                if (mode1Radio.checked) {
                    updateConfigTemplates(deviceId, macNoColons, type, version, false);
                }
            });
            
            mode2Radio.addEventListener('change', () => {
                if (mode2Radio.checked) {
                    updateConfigTemplates(deviceId, macNoColons, type, version, true);
                }
            });
        }
        
        // Update configuration templates
        function updateConfigTemplates(deviceId, mac, type, version, inverseForwarding = false) {
            // Docker configuration
            const dockerConfig = {
                "broker_url": "mqtt://username:password@your-broker-url",
                "inverse_forwarding": inverseForwarding,
                "devices": [
                    {
                        "device_id": deviceId || "your-device-id",
                        "mac": mac || "your-mac-address",
                        "type": type || "your-device-type",
                        "version": parseInt(version, 10) || 0
                    }
                ]
            };
            
            document.getElementById('docker-config').textContent = JSON.stringify(dockerConfig, null, 2);
            
            // Home Assistant configuration
            const haConfig = `inverse_forwarding: ${inverseForwarding}
devices:
  - device_id: "${deviceId || 'your-device-id'}"
    mac: "${mac || 'your-mac-address'}"
    type: "${type || 'your-device-type'}"
    version: ${parseInt(version, 10) || 0}`;
            
            document.getElementById('ha-config').textContent = haConfig;
            
            // hm2mqtt Home Assistant configuration
            const hm2mqttHaConfig = `pollingInterval: 60
responseTimeout: 30
topicPrefix: hm2mqtt
devices:
  - deviceType: "${type || 'your-device-type'}"
    deviceId: "${mac || 'your-device-mac'}"`;
            
            document.getElementById('hm2mqtt-ha-config').textContent = hm2mqttHaConfig;
            
            // hm2mqtt Docker configuration
            const hm2mqttDockerConfig = `docker run -d --name hm2mqtt \\
  -e MQTT_BROKER_URL=mqtt://192.168.1.100:1883 \\
  -e MQTT_USERNAME=your-username \\
  -e MQTT_PASSWORD=your-password \\
  -e DEVICE_0=${type || 'your-device-type'}:${mac || 'your-device-mac'} \\
  --restart=unless-stopped \\
  ghcr.io/tomquist/hm2mqtt:latest`;
            
            document.getElementById('hm2mqtt-docker-config').textContent = hm2mqttDockerConfig;
        }
        
        // Copy to clipboard function
        function copyToClipboard(elementId) {
            const element = document.getElementById(elementId);
            const text = element.textContent;
            
            navigator.clipboard.writeText(text).then(() => {
                // Visual feedback
                const button = event.target;
                const originalText = button.textContent;
                button.textContent = 'Copied!';
                button.style.backgroundColor = '#27ae60';
                
                setTimeout(() => {
                    button.textContent = originalText;
                    button.style.backgroundColor = '#3498db';
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy: ', err);
                alert('Failed to copy to clipboard. Please copy manually.');
            });
        }

        // Event listeners
        connectButton.addEventListener('click', connectToDevice);
        disconnectButton.addEventListener('click', disconnectFromDevice);
        getInfoButton.addEventListener('click', getDeviceInformation);
        setMqttButton.addEventListener('click', setMqttConfig);
        resetMqttButton.addEventListener('click', resetMqttConfig);
        
        // Check if Web Bluetooth API is supported
        if (!navigator.bluetooth) {
            log('Web Bluetooth API is not supported in this browser');
            alert('Web Bluetooth is not supported in this browser. Please use Chrome, Edge, or Opera.');
            connectButton.disabled = true;
        } else {
            log('Web Bluetooth API is supported');
            
            // Add information about device detection
            log('Tips for device detection:');
            log('1. Make sure your device is powered on and in range');
            log('2. Ensure the device is advertising');
            log('3. Try restarting your Bluetooth adapter if needed');
            
            // Display browser information
            log(`Browser: ${navigator.userAgent}`);
        }

        // --- Add topic display to device info UI ---
        // Add rows for both topics and an info note, but use generic placeholders for now
        (function addTopicRows() {
            const infoContainer = document.querySelector('.info-container');
            // For >= threshold
            const topicGELabel = document.createElement('div');
            topicGELabel.id = 'device-topic-ge-label';
            topicGELabel.textContent = 'Topic for firmware >=XXX:';
            const topicGEValue = document.createElement('div');
            topicGEValue.id = 'device-topic-ge';
            topicGEValue.className = 'topic-mono';
            infoContainer.appendChild(topicGELabel);
            infoContainer.appendChild(topicGEValue);
            // App topic for >= threshold
            const topicGEAppLabel = document.createElement('div');
            topicGEAppLabel.id = 'device-topic-ge-app-label';
            const topicGEAppValue = document.createElement('div');
            topicGEAppValue.id = 'device-topic-ge-app';
            topicGEAppValue.className = 'topic-mono';
            infoContainer.appendChild(topicGEAppLabel);
            infoContainer.appendChild(topicGEAppValue);
            // For < threshold
            const topicLTLabel = document.createElement('div');
            topicLTLabel.id = 'device-topic-lt-label';
            topicLTLabel.textContent = 'Topic for firmware <XXX:';
            const topicLTValue = document.createElement('div');
            topicLTValue.id = 'device-topic-lt';
            topicLTValue.className = 'topic-mono';
            infoContainer.appendChild(topicLTLabel);
            infoContainer.appendChild(topicLTValue);
            // App topic for < threshold
            const topicLTAppLabel = document.createElement('div');
            topicLTAppLabel.id = 'device-topic-lt-app-label';
            const topicLTAppValue = document.createElement('div');
            topicLTAppValue.id = 'device-topic-lt-app';
            topicLTAppValue.className = 'topic-mono';
            infoContainer.appendChild(topicLTAppLabel);
            infoContainer.appendChild(topicLTAppValue);
        })();
    </script>
</body>
</html>